# TOML

## 简介

一种语义明显而又易于阅读的配置文件格式。

## 特性

* 以 `.toml` 作为文件后缀名
* 大小写敏感
* 必须是有效的 UTF-8 编码的 Unicode 文档

## 注释

```toml
# 整行注释

key = "value" # 行内注释
```

## 键值对

TOML 文件的基本构成，有如下特性：

* key 在等号左边而 value 在等号右边
* key 和 value 周围的空白会被忽略
* key、等号和 value 必须在同一行（不过 value 可以横跨多行）
* 键值对后必须换行，即一行内不允许出现两对键值对
* key 可以是裸露的、引用包裹的或者点分隔的（推荐用裸键）
* 不允许出现相同的键

```toml
# 裸键, 只能包含 ASCII 码字母、ASCII 码数字、下划线和短横线 (A-Za-z0-9_-)
key = "value"

# 引用包裹的键
"key" = "value"

# 点分割键是一系列通过点相连的键
physical.color = "橙色"
physical.shape = "圆形"
# 对应的 json 如下:
{
  "physical": {
    "color": "橙色",
    "shape": "圆形"
  }
}
```

值必须是以下类型之一：

* 字符串
* 整数
* 浮点数
* 布尔值
* 坐标日期时刻
* 各地日期时刻
* 各地日期
* 各地时刻
* 数组
* 行内表

## 字符串

### 1. 基础字符串

任何 Unicode 字符都可以使用，除了必须转义的（引号、反斜杠、除 Tab 外的控制字符）：

```toml
str = "我是一个字符串。\"你可以把我引起来\"。姓名\tJos\u00E9\n位置\t旧金山。"
```

### 2. 多行基础字符串

由三个引号包裹，紧随开头引号的换行符会被去除，其他空白和换行符会被保留：

```toml
str = """
玫瑰是红色的
紫罗兰是蓝色的"""
```

当书写长字符串却不想引入无关空白时可以使用“行末反斜杠”：

```toml
# 下列字符串的每一个字节都完全相同：

str1 = "那只敏捷的棕狐狸跳过了那只懒狗。"

str2 = """
那只敏捷的棕\


  狐狸跳过了\
    那只懒狗。"""

str3 = """\
       那只敏捷的棕\
       狐狸跳过了\
       那只懒狗。\
       """
```

### 3. 字面量字符串

字面量字符串是“所见即所得”的字符串，它完全不允许转义，因此在指定 Windows 路径或者正则表达式时会显得更加直观：

```toml
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = '汤姆·"达布斯"·普雷斯顿—维尔纳'
regex    = '<\i\c*\s*>'
```

### 4. 多行字面量字符串

由于没有转义，无法在由单引号包括的字面量字符串中写入单引号，我们可以通过多行字面量字符串来解决这个问题：

```toml
regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
原始字符串中的
第一个换行被剔除了。
   所有其它空白
   都保留了。
'''
```

## 整数

* 支持正负号
* 对于大数可以通过下划线来增加可读性
* 不支持前导零
* 非负整数可以用十六进制、八进制和二进制来表示，在这些格式中：
  * 不允许加上正号 `+`
  * 支持前导零
  * 十六进制大小写不敏感
  * 数字键的下划线是允许的
* 任何 64 位有符号整数（-2^63 到 2^63 + 1）都应当被接受并无损处理

```toml
# 普通整数
int1 = +99
int2 = 42
int3 = 0
int4 = -17

# 大数
int5 = 1_000
int6 = 5_349_221
int7 = 53_49_221  # 印度记数体系分组
int8 = 1_2_3_4_5  # 无误但不鼓励

# 带有 `0x` 前缀的十六进制
hex1 = 0xDEADBEEF
hex2 = 0xdeadbeef
hex3 = 0xdead_beef

# 带有 `0o` 前缀的八进制
oct1 = 0o01234567
oct2 = 0o755 # 对于表示 Unix 文件权限很有用

# 带有 `0b` 前缀的二进制
bin1 = 0b11010110
```

## 浮点数

```toml
# 小数
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# 指数
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

# 都有
flt7 = 6.626e-34

# 通过下划线增强可读性
flt8 = 224_617.445_991_228

# 无穷
sf1 = inf  # 正无穷
sf2 = +inf # 正无穷
sf3 = -inf # 负无穷

# 非数
sf4 = nan  # 实际上对应信号非数码还是静默非数码，取决于实现
sf5 = +nan # 等同于 `nan`
sf6 = -nan # 正确，实际码取决于实现
```

## 布尔值

```toml
bool1 = true
bool2 = false
```

## 坐标日期时刻

```toml
# 可以使用指定了时针偏移量的 RFC 3339 格式的日期时刻
odt1 = 1979-05-27T07:32:00Z
odt2 = 1979-05-27T00:32:00-07:00
odt3 = 1979-05-27T00:32:00.999999-07:00

# 可以使用空格替换日期和时刻之间的 T 来增强可读性
odt4 = 1979-05-27 07:32:00Z
```

## 各地日期时刻

如果你忽略了 RFC 3339 日期时刻中的时区偏移量，这表示该日期时刻的使用并不涉及时区偏移。

```toml
ldt1 = 1979-05-27T07:32:00
ldt2 = 1979-05-27T00:32:00.999999
```

## 各地日期

如果你只写了 RFC 3399 日期时刻中的日期部分那它表示一整天，同时也不涉及时区偏移：

```toml
ld1 = 1979-05-27
```

## 各地时刻

如果你只写了 RFC 3399 日期时刻中的时刻部分，它将只表示一天之中那个时刻，而与特定的日期无关，并不涉及时区偏移：

```toml
lt1 = 07:32:00
lt2 = 00:32:00.999999
```

## 数组

* 数组是内含值的方括号
* 空白会被忽略
* 子元素由逗号分隔
* 数组可以包含与键值对所允许的相同数据类型的值
* 可以混合不同类型的值
* 数组可以跨行
* 数组的最后一个值后面可以有终括号（也被叫做尾括号）

```toml
# 数组
integers = [ 1, 2, 3 ]
colors = [ "红", "黄", "绿" ]
nested_array_of_ints = [ [ 1, 2 ], [3, 4, 5] ]
nested_mixed_array = [ [ 1, 2 ], ["a", "b", "c"] ]
string_array = [ "所有的", '字符串', """是相同的""", '''类型''' ]

# 允许混合类型的数组
numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]
contributors = [
  "Foo Bar <foo@example.com>",
  { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
]

# 数组可以跨行
integers2 = [
  1, 2, 3
]

integers3 = [
  1,
  2, # 这是可以的
]
```

## 表

* 表是键值对的集合
* 由表头定义，连同方括号一起作为单独的行出现

```toml
[table-1]
key1 = "some string"
key2 = 123

[table-2]
key1 = "another string"
key2 = 456
```

顶层表（根表）在文档开始处并在第一个表头（或者文件结束处）前结束。不同于其他表它没有名字且无法后置。

```toml
# 顶层表开始。
name = "Fido"
breed = "哈巴狗"

# 顶层表结束。
[owner]
name = "Regina Dogman"
member_since = 1999-08-04
```

## 行内表

* 行内表提供了一种更为紧凑的方式来表示表
* 行内表被完整地定义在花括号中 `{}`
* 花括号中可以出现零个或多个以逗号分隔的键值对
* 行内表不允许花括号中出现任何换行，除非在值中它们有效，即便如此也强烈不建议把一个行内表改成横跨多行的模式

```toml
# 行内表
name = { first = "汤姆", last = "普雷斯顿—维尔纳" }
point = { x = 1, y = 2 }
animal = { type.name = "哈巴狗" }

# 等价于如下的标准表
[name]
first = "汤姆"
last = "普雷斯顿—维尔纳"

[point]
x = 1
y = 2

[animal]
type.name = "哈巴狗"

# 行内表是独立自足的，在内部定义全部的 kv 对，不允许在括号外再添加 kv 对
[product]
type = { name = "钉子" }
# type.edible = false  # 错误

[product]
type.name = "钉子"
# type = { edible = false }  # 错误
```

## 表数组

表头的第一例定义了这个数组及其首个表元素，而后续的每个则在该数组中创建并定义一个新的表元素。这些表按出现顺序插入该数组：

```toml
# 表数组
[[products]]
name = "锤子"
sku = 738594937

[[products]]  # 数组里的空表

[[products]]
name = "钉子"
sku = 284758393

color = "灰色"

# 对应的 json 表示如下
{
  "products": [
    { "name": "锤子", "sku": 738594937 },
    { },
    { "name": "钉子", "sku": 284758393, "color": "gray" }
  ]
}

# 任何对表数组的引用都指向该数组里最近定义的表元素, 这允许你在最近的表内定义子表，甚至子表数组
[[fruits]]
name = "苹果"

[fruits.physical]  # 子表
color = "红色"
shape = "圆形"

[[fruits.varieties]]  # 嵌套表数组
name = "蛇果"

[[fruits.varieties]]
name = "澳洲青苹"

[[fruits]]
name = "香蕉"

[[fruits.varieties]]
name = "车前草"

# 对应的 json 如下
{
  "fruits": [
    {
      "name": "苹果",
      "physical": {
        "color": "红色",
        "shape": "圆形"
      },
      "varieties": [
        { "name": "蛇果" },
        { "name": "澳洲青苹" }
      ]
    },
    {
      "name": "香蕉",
      "varieties": [
        { "name": "车前草" }
      ]
    }
  ]
}
```

你也可以适当地使用行内表实现这个功能：

```toml
points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
```

## Reference

[1] <https://github.com/LongTengDao/TOML>
